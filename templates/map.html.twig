<html lang="en">
<head>
    <title>Interactive Map</title>
    <!-- Include Leaflet CSS -->
    <link rel="icon"
          href="https://cdn2.steamgriddb.com/file/sgdb-cdn/icon/9e1c574347088c9225f323757f547b06/32/96x96.png"
          type="image/x-icon">
    <style> /* Body styles */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Lucida Grande', Geneva, Arial, Verdana, sans-serif;
            background-color: #282c34; /* Dark background color */
            color: #fff; /* Text color */
        }

        /* Header styles */
        #header {
            background-color: #222; /* Darker header background color */
            color: #ff4d4d; /* Slight red header text color */
            padding: 10px;
        }

        #header h1 {
            margin: 0;
        }

        #subheader {
            text-align: left;
            font-size: 14px;
            color: #ccc;
        }

        /* Map container styles */
        #map-container {
            width: 100%;
            height: calc(100vh - 135px); /* Adjust 100px to account for other elements on the page */
            border: 1px solid #888;
            background-color: #333; /* Darker map container background color */
        }

        /* Popup css */
        .ol-popup {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 30px 10px 10px;
            border: 1px solid #ff0000; /* Use red color for the border */
            border-radius: 10px; /* Increase the border-radius for a smoother appearance */
            font-size: 14px; /* Slightly increase the font size for better readability */
            color: #fff; /* Use white color for the text */
            display: none;
            z-index: 1000; /* Increase this value if necessary */
        }

        .ol-popup-closer {
            text-decoration: none;
            position: absolute;
            top: 2px;
            right: 8px;
            width: 20px;
            height: 20px;
            font-size: 20px;
            font-weight: bold;
            line-height: 20px;
            text-align: center;
            color: #ff0000; /* Set the desired color for the closer icon */
            cursor: pointer;
        }

        .ol-popup-closer:hover {
            color: #c3c3c3;
        }

    </style>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ol@v7.4.0/dist/ol.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v7.4.0/ol.css">
</head>
<body style="">

<div id="header">
    <h1>V rising</h1>
    <hr>
    <div id="subheader">
        <h2>Interactive map</h2>
    </div>
    <!-- uncomment for coordinate info (debug) you also need to uncomment the code in the script section -->
      <div id="coordinates-info" style="position: absolute; top: 10px; left: 10px; background-color: white; padding: 5px;"></div>

</div>
<div id="map-container" style="width: 99.9%;">
    <div id="popup" class="ol-popup">
        <a href="#" id="popup-closer" class="ol-popup-closer">X</a>
        <div id="popup-content"></div>
    </div>
</div>

<script>
    // Change scale or color of images here if you need to
    // if you want to add a color to a specific image, add it to the imageStyles object
    // just add color: 'your color here' to the image you want to change
    const castleColor = '#12c8d9';
    const castleScale = 0.75;
    const miscScale = 1;
    const imageStyles = {
        Dot: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/Dot.png',
            scale: 1,
        }),
        Gateway: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/Gateway.png',
            scale: 1,
        }),
        TeamGateway: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/TeamGateway.png',
            scale: 1,
        }),
        PlayerCastle: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/PlayerCastle.png',
            scale: castleScale,
        }),
        DecayedPlayerCastle: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/DecayedPlayerCastle.png',
            scale: castleScale,
        }),
        PlayerCastleT1: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/PlayerCastleT1.png',
            scale: castleScale,
            color: castleColor,
        }),
        PlayerCastleT2: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/PlayerCastleT2.png',
            scale: castleScale,
            color: castleColor,
        }),
        PlayerCastleT3: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/PlayerCastleT3.png',
            scale: castleScale,
            color: castleColor,
        }),
        PlayerCastleT4: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/PlayerCastleT4.png',
            scale: castleScale,
            color: castleColor,
        }),
        SiegeGolem: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/SiegeGolem.png',
            scale: 0.75,
        }),
        Anvil: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/Anvil.png',
            scale: miscScale,
        }),
        Armor: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/Armor.png',
            scale: miscScale,
        }),
        BloodAltar: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/BloodAltar.png',
            scale: 1,
        }),
        Cave: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/Cave.png',
            scale: 0.75,
        }),
        Encampment: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/Encampment.png',
            scale: 0.5,
        }),
        Fortification: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/Fortification.png',
            scale: 0.5,
        }),
        Health: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/Health.png',
            scale: 0.75,
        }),
        Magic: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/Magic.png',
            scale: 0.5,
        }),
        Mine: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/Mine.png',
            scale: 0.5,
        }),
        Relic: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/Relic.png',
            scale: 0.25,
        }),
        Research: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/Research.png',
            scale: miscScale,
        }),
        Throne: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/Throne.png',
            scale: miscScale,
        }),
        Trader: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/Trader.png',
            scale: 0.5,
        }),
        WorkBench: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/WorkBench.png',
            scale: 0.5,
        }),
        Marker: new ol.style.Icon({
            src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/Marker.png',
            scale: 0.75,
        })
    };


    // DO NOT EDIT ANYTHING BELOW THIS LINE
    const inGamePoints = [
        [-2018.579, -1867.3538],
        [-1175.4547, 299.77496],
        [-1848.4547, 384.77496],
        [-2459.45, -1064.1505],
        [-1252.9863, -1360.7368]
    ];

    const onlinePoints = [
        [-921.35, -1522.96],
        [329.30, 1696.11],
        [-667.34, 1822.45],
        [-1574.62, -329.53],
        [214.99, -771.30]
    ];

    const inGameOrigin = [2098, 1225];
    const onlineMapOrigin = [-1400, -843];

    // Adjust points based on origins
    const adjustedInGamePoints = inGamePoints.map(point => [
        point[0] - inGameOrigin[0],
        point[1] - inGameOrigin[1]
    ]);

    const adjustedOnlinePoints = onlinePoints.map(point => [
        point[0] - onlineMapOrigin[0],
        point[1] - onlineMapOrigin[1]
    ]);

    // Calculate scaling factors
    const scaleX = (adjustedOnlinePoints[1][0] - adjustedOnlinePoints[0][0]) / (adjustedInGamePoints[1][0] - adjustedInGamePoints[0][0]);
    const scaleY = (adjustedOnlinePoints[1][1] - adjustedOnlinePoints[0][1]) / (adjustedInGamePoints[1][1] - adjustedInGamePoints[0][1]);

    // Calculate offsets
    const offsetX = adjustedOnlinePoints[0][0] - scaleX * adjustedInGamePoints[0][0];
    const offsetY = adjustedOnlinePoints[0][1] - scaleY * adjustedInGamePoints[0][1];

    const mapMinZoom = 0;
    const mapMaxZoom = 5;
    let myMap = null;
    let playerVectorLayer = null;
    let markerVectorLayer = null;
    let playerCounter = 0;
    let markerCounter = 0;
    let customPlayerControl = null;
    let customMarkerControl = null;
    let visibilityPlayers = true;
    let visibilityCustomMarkers = true;
    let Noplayers = false;
    let selectedFeature = null;

    function transform(x, y) {
        // Adjust coordinates based on in-game origin before transformation
        const adjustedX = x - inGameOrigin[0];
        const adjustedY = y - inGameOrigin[1];

        // Apply scaling and offset
        const X = scaleX * adjustedX + offsetX + onlineMapOrigin[0];
        const Y = scaleY * adjustedY + offsetY + onlineMapOrigin[1];

        return [X, Y];
    }

    function convertCoordinates(playerX, playerY) {
        const [X_web, Y_web] = transform(playerX, playerY);
        return { X_web, Y_web };
    }

    function convertCoordinatesArray(playerX, playerY) {
        return transform(playerX, playerY);
    }



    function getPlayerPositions() {
        return fetch('/map-data-player')
            .then(response => response.json()) // Parse the JSON data from the response
            .then(data => {
                // Convert the JSON data to a JavaScript array (List equivalent)
                return JSON.parse(data);
            })
            .catch(error => {
                return []; // Return an empty array in case of an error
            });
    }

    function getInterval() {
        return fetch('/map-update')
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.text(); // Assuming the server returns the integer as text data
            })
            .then(data => {
                const intValue = parseInt(data); // Parse the received data as an integer
                if (!isNaN(intValue)) {
                    return intValue * 1000;
                    // Use the integer value in your application as needed
                } else {
                    return 10000; // Return a default value if the received data is not a valid integer
                }
            })
            .catch(error => {
                console.error('Error fetching data:', error);
                return 10000; // Return a default value in case of an error
            });
    }

    function getRegions() {
        return fetch('/map-data-regions')
            .then(response => response.json()) // Parse the JSON data from the response
            .then(data => {
                // Convert the JSON data to a JavaScript array (List equivalent)
                return JSON.parse(data);
            })
            .catch(error => {
                console.error('Error fetching region map data:', error);
                return []; // Return an empty array in case of an error
            });
    }

    function getTerritories() {
        return fetch('/map-data-Territories')
            .then(response => response.json()) // Parse the JSON data from the response
            .then(data => {
                // Convert the JSON data to a JavaScript array (List equivalent)
                return JSON.parse(data);
            })
            .catch(error => {
                console.error('Error fetching territory map data:', error);
                return []; // Return an empty array in case of an error
            });
    }

    function getCustomMarkers() {
        return fetch('/map-data-CustomMarkers')
            .then(response => response.json()) // Parse the JSON data from the response
            .then(data => {
                // Convert the JSON data to a JavaScript array (List equivalent)
                return JSON.parse(data);
            })
            .catch(error => {
                console.error('Error fetching custom marker map data:', error);
                return []; // Return an empty array in case of an error
            });
    }

    class ShowHideControl extends ol.control.Control {
        /**
         * @param {Object} [layer] Control options.
         * @param shortName
         * @param longName
         */
        constructor(layer, shortName, longName) {
            const button = document.createElement('button');
            button.innerHTML = shortName;
            button.title = longName;

            const element = document.getElementsByClassName('ol-zoom')[0];
            // Check if the class 'custom-layer-toggle-control' already exists in the className
            if (element.className.indexOf('custom-layer-toggle-control') === -1) {
                // If the class does not exist, add it to the className
                element.className += ' custom-layer-toggle-control';
            }
            element.appendChild(button);

            super({
                element: element,
                target: null,
            });

            this.layer = layer;
            button.addEventListener('click', this.toggleLayerVisibility.bind(this), false);
        }

        toggleLayerVisibility() {
            this.layer.setVisible(!this.layer.getVisible());
        }
    }

    function insertSpaces(input) {
        // Use regular expression to add spaces before capital letters and remove underscores
        return input.replace(/([A-Z])|_/g, function (match, letter) {
            return letter ? ' ' + letter : '';
        }).trim();
    }

    let markerVectorSource = null;
    let markerClusterStrategy = null;



    function updateCustomMarkers() {
        getCustomMarkers().then(markerData => {

            let mapMarkerData = [];
            markerData.forEach(function (data) {
                mapMarkerData.push({lon: data.X, lat: data.Y, label: data.MarkerName, type: data.MarkerType})
            });

            let markerFeatures = [];

            mapMarkerData.forEach(function (data) {
                const { X_web, Y_web } = convertCoordinates(data.lon, data.lat);
                const feature = new ol.Feature({
                    geometry: new ol.geom.Point(([X_web, Y_web])),
                    name: data.label,
                    markerType: data.type
                });
                markerFeatures.push(feature);
            });




            markerVectorSource = new ol.source.Vector({
                features: markerFeatures
            });

            markerClusterStrategy = new ol.source.Cluster({
                distance: 40,
                minDistance: 10,
                source: markerVectorSource
            });

            if (markerCounter !== 0) {
                myMap.removeLayer(markerVectorLayer);
                if (customMarkerControl !== null) {
                    visibilityCustomMarkers = customMarkerControl.layer.getVisible()
                    myMap.removeControl(customMarkerControl);
                }
            }

            markerVectorLayer = new ol.layer.Vector({
                source: markerClusterStrategy,
                style: function (feature) {
                    // Check if it's a cluster feature
                    if (feature.get('features')) {
                        const clusterFeatures = feature.get('features');
                        const markerStyles = [];

                        // Iterate through individual markers in the cluster
                        clusterFeatures.forEach(function (individualFeature) {
                            const markerType = individualFeature.get('markerType');
                            const imageStyle = new ol.style.Style({
                                image: imageStyles[markerType],
                                text: new ol.style.Text({
                                    fill: new ol.style.Fill({ color: 'white' }),
                                    font: '22px Calibri,sans-serif',
                                    offsetY: -20,
                                }),
                            });

                            if (clusterFeatures.length > 1) {
                                // Hide the text label for clustered features with more than 1 feature
                                imageStyle.getText().setText('');
                            } else {
                                // Show the text label for clustered features when they are alone
                                imageStyle.getText().setText(individualFeature.get('name'));
                            }

                            markerStyles.push(imageStyle);
                        });

                        return markerStyles;
                    } else {
                        // For non-clustered features (individual markers)
                        const markerType = feature.get('markerType');
                        const imageStyle = new ol.style.Style({
                            image: imageStyles[markerType],
                            text: new ol.style.Text({
                                fill: new ol.style.Fill({ color: 'white' }),
                                font: '22px Calibri,sans-serif',
                                offsetY: -15,
                            }),
                        });

                        // Show the text label for individual features
                        imageStyle.getText().setText(feature.get('name'));

                        return [imageStyle];
                    }
                },
            });

            if (markerCounter === 0) {
                markerCounter = 1;
            }

            if (customMarkerControl === null) {
                customMarkerControl = new ShowHideControl(markerVectorLayer, "TC", "Toggle Custom Markers");
            } else {
                customMarkerControl.layer = markerVectorLayer;
                customMarkerControl.layer.setVisible(visibilityCustomMarkers);
            }


            myMap.addControl(customMarkerControl);
            myMap.addLayer(markerVectorLayer);



            //testing


            const markerSource = new ol.source.Vector();
            const markerLayer = new ol.layer.Vector({
                source: markerSource
            });

            // Define a style for the marker
            const markerStyle = new ol.style.Style({
                image: new ol.style.Circle({
                    radius: 6,
                    fill: new ol.style.Fill({ color: 'red' }),
                    stroke: new ol.style.Stroke({
                        color: 'white',
                        width: 2
                    })
                })
            });

            // Create a marker feature at the in-game origin point
            const markerFeature = new ol.Feature({
                geometry: new ol.geom.Point(inGameOrigin)
            });
            markerFeature.setStyle(markerStyle);

            // Add the marker feature to the marker layer
            markerSource.addFeature(markerFeature);

            // Add the marker layer to the map
            myMap.addLayer(markerLayer);

            //endtesting


        });
    }

    function updateTerritory() {
        getTerritories().then(territoryData => {
            for (let i = 0; i < territoryData.length; i++) {
                territoryData[i].Territory = insertSpaces(territoryData[i].Territory);
            }

            let regionData = [
                {lon: 0, lat: 0, label: '', PlayerCount: 0}, //Silverlight Hills  lon: 1901, lat: 586
                {lon: 0, lat: 0, label: '', PlayerCount: 0}, //Dunley Farmlands lon: 5444, lat: 825
                {lon: 0, lat: 0, label: '', PlayerCount: 0}, //Farbane Woods lon: 5087, lat: -2662
                {lon: 0, lat: 0, label: '', PlayerCount: 0}, //Cursed Forest lon: 7886, lat: 3931
                {lon: 0, lat: 0, label: '', PlayerCount: 0}, //Hallowed Mountains lon: 9051, lat: 491
                {lon: 0, lat: 0, label: '', PlayerCount: 0}, //Ruins of Mortium
                {lon: 0, lat: 0, label: '', PlayerCount: 0}, //Gloomrot South lon: 4865, lat: 3649
                {lon: 0, lat: 0, label: '', PlayerCount: 0}, //Gloomrot North lon: 3054, lat: 3709
                {lon: 0, lat: 0, label: '', PlayerCount: 0}, //Starter Cave
            ];
            let TotalPlayerCounter = 0;
            for (let i = 0; i < regionData.length; i++) {
                TotalPlayerCounter += territoryData[i].PlayerCount;
                regionData[i].label = territoryData[i].Territory;
                regionData[i].PlayerCount = territoryData[i].PlayerCount;
                const { X_web, Y_web } = convertCoordinates(territoryData[i].X, territoryData[i].Y);
                regionData[i].lon = X_web;
                regionData[i].lat = Y_web;
                //console.log("regionName:" + regionData[i].label + " PosX: " + regionData[i].lon + " PosY: " + regionData[i].lat)

            }
            console.log("Total Players: " + TotalPlayerCounter);
            //Create features and add them to the vector layer
            let features = [];

            regionData.forEach(function (data) {
                const feature = new ol.Feature({
                    geometry: new ol.geom.Point(([parseFloat(data.lon), parseFloat(data.lat)])),
                    name: data.label,
                });
                features.push(feature);
            });

            let testCornerData = [
                {lon: -2200, lat: -2312, label: 'bottom left', PlayerCount: 0}, // bottom left corner coordinates of online map
                {lon: 2312, lat: 2200, label: 'top right', PlayerCount: 0}, // top right corner coordinates of online map
                {lon: 2312, lat: -2312, label: 'bottom right', PlayerCount: 0}, // bottom right corner coordinates of online map
                {lon: -2200, lat: 2200, label: 'top left', PlayerCount: 0}, // top left corner coordinates of online map
                {lon: -2200, lat: 2200, label: 'top left', PlayerCount: 0}, // top left corner coordinates of online map
                {lon: 0, lat: 0, label: 'center', PlayerCount: 0}
            ];

            testCornerData.forEach(function (data) {
                const feature = new ol.Feature({
                    geometry: new ol.geom.Point(([parseFloat(data.lon), parseFloat(data.lat)])),
                    name: data.label,
                });
                features.push(feature);
            });

            const vectorSource = new ol.source.Vector({
                features: features
            });

            const clusterStrategy = new ol.source.Cluster({
                distance: 75,
                source: vectorSource
            });



            const vectorLayer = new ol.layer.Vector({
                source: clusterStrategy,
                style: function (feature) {
                    if (feature.get('features')) {
                        const clusterFeatures = feature.get('features');
                        const markerStyles = [];
                        var GloomRotAssigned = false
                        // Iterate through individual markers in the cluster
                        clusterFeatures.forEach(function (individualFeature) {

                            const imageStyle = new ol.style.Style({
                                image: new ol.style.Icon({
                                    src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/Dot.png',
                                    scale: 1,
                                }),
                                text: new ol.style.Text({
                                    fill: new ol.style.Fill({color: 'white'}),
                                    font: '22px Calibri,sans-serif',
                                    offsetY: -15,
                                }),
                            });

                            if (clusterFeatures.length > 1) {
                                // Hide the text label for clustered features with more than 1 feature
                                if (!GloomRotAssigned) {
                                    imageStyle.getText().setText('Gloomrot');
                                    GloomRotAssigned = true;
                                } else {
                                    imageStyle.getText().setText('');
                                }
                            } else {
                                // Show the text label for clustered features when they are alone
                                imageStyle.getText().setText(individualFeature.get('name'));
                            }

                            markerStyles.push(imageStyle);
                        });

                        return markerStyles;

                    } else {
                        const imageStyle = new ol.style.Style({
                            image: new ol.style.Icon({
                                src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/Dot.png',
                                scale: 1,
                            }),
                            text: new ol.style.Text({
                                fill: new ol.style.Fill({color: 'white'}),
                                font: '22px Calibri,sans-serif',
                                offsetY: -15,
                            }),
                        });
                        // For non-clustered features (individual markers)
                        // Show the text label for individual features
                        imageStyle.getText().setText(feature.get('name'));

                        return [imageStyle];
                    }
                }
            });
            const customControl = new ShowHideControl(vectorLayer, "TR", "Toggle Regions");
            myMap.addControl(customControl);
            myMap.addLayer(vectorLayer);

            const clickableSimpleRegions = [
                {bottomLeft: [0, 0], topRight: [0, 0], label: '', territoryId: 1},
                {bottomLeft: [0, 0], topRight: [0, 0], label: '', territoryId: 2},
                {bottomLeft: [0, 0], topRight: [0, 0], label: '', territoryId: 3},
                {bottomLeft: [0, 0], topRight: [0, 0], label: '', territoryId: 4},
                {bottomLeft: [0, 0], topRight: [0, 0], label: '', territoryId: 5},
                {bottomLeft: [0, 0], topRight: [0, 0], label: '', territoryId: 8}
            ];
            const clickableComplexRegions = [
                {
                    label: 'Gloomrot North', points: [
                        [0, 0], // Bottom left
                        [0, 0], // Top left
                        [0, 0], // Middle left
                        [0, 0], // Middle right
                        [0, 0], // Top right
                        [0, 0], // Bottom right
                        [0, 0], // Bottom left
                    ], territoryId: 7
                },
                {
                    label: 'Gloomrot South', points: [
                        [0, 0], // Bottom left
                        [0, 0], // Top left
                        [0, 0], // Middle left
                        [0, 0], // Middle right
                        [0, 0], // Top right
                        [0, 0], // Bottom right
                        [0, 0], // Bottom left
                    ], territoryId: 6
                },
                // Add other regions here...
            ];
            const regionVectorSource = new ol.source.Vector;
            const removeOverlappingAreasWithExistingFeatures = (feature, priorityLevels) => {
                const format = new ol.format.GeoJSON();

                regionVectorSource.getFeatures().forEach((existingFeature) => {
                    if (
                        existingFeature.getGeometry().getType() !== 'Polygon' ||
                        !existingFeature.get('name') ||
                        existingFeature.get('name') === feature.get('name')
                    )
                        return;

                    const existingPriority = priorityLevels.indexOf(existingFeature.get('name'));
                    const featurePriority = priorityLevels.indexOf(feature.get('name'));

                    // If the existing feature has a higher priority, skip this feature
                    if (existingPriority > featurePriority) return;

                    var featurePoly = format.writeFeatureObject(feature);
                    var existingFeaturePoly = format.writeFeatureObject(existingFeature);

                    const intersection = turf.intersect(featurePoly, existingFeaturePoly);
                    if (intersection) {
                        var difference = turf.difference(featurePoly, intersection);

                        difference.geometry.coordinates =
                            difference.geometry.coordinates.filter(
                                (coordinate) => coordinate.length > 0
                            );

                        feature.setGeometry(format.readFeature(difference).getGeometry());
                    }
                });

                return feature;
            };
            // setting up correct shape for complex regions
            clickableComplexRegions.forEach((region) => {
                for (let i = 0; i < territoryData.length; i++) {
                    if (region.label === territoryData[i].Territory && territoryData[i].Territory === "Gloomrot North") {
                        let { BottomLeftX, BottomLeftY } = convertCoordinates(territoryData[i].BX,territoryData[i].BY)
                        let { TopRightX, TopRightY } = convertCoordinates(territoryData[i].TX,territoryData[i].TY)
                        let MiddleY = (BottomLeftY + TopRightY) / 2;
                        let TopLeftX = BottomLeftX;
                        let MiddleRightX = TopRightX;
                        let BottomRight = [TopRightX - 1500, BottomLeftY + 40];
                        let BottomLeft = [BottomLeftX, BottomLeftY + 40];
                        let TopRight = [TopRightX, TopRightY];
                        let TopLeft = [TopLeftX, TopRightY];
                        let OuterMiddleRight = [MiddleRightX, MiddleY - 110];
                        let InnerMiddleRight = [MiddleRightX - 1500, MiddleY - 110];

                        // are original points
                        region.points[0] = BottomLeft;// Bottom left
                        region.points[1] = TopLeft; // Middle left
                        region.points[2] = TopRight; // Top left
                        region.points[3] = OuterMiddleRight; // top right
                        region.points[4] = InnerMiddleRight; // Middle right
                        region.points[5] = BottomRight; // Bottom right
                        region.points[6] = BottomLeft;// Bottom left
                    }
                    if (region.label === territoryData[i].Territory && territoryData[i].Territory === "Gloomrot South") {

                        let { BottomLeftX, BottomLeftY } = convertCoordinates(territoryData[i].BX,territoryData[i].BY)
                        let { TopRightX, TopRightY } = convertCoordinates(territoryData[i].TX,territoryData[i].TY)
                        let MiddleY = (BottomLeftY + TopRightY) / 2;
                        let TopLeftX = BottomLeftX;
                        let MiddleLeftX = BottomLeftX;
                        let BottomRight = [TopRightX - 112, BottomLeftY];
                        let BottomLeft = [BottomLeftX + 384, BottomLeftY];
                        let TopRight = [TopRightX - 112, TopRightY];
                        let TopLeft = [TopLeftX + 1884, TopRightY];
                        let MiddleInnerLeft = [MiddleLeftX + 1884, MiddleY + 107];
                        let MiddleLeft = [MiddleLeftX + 384, MiddleY + 107];


                        // are original points
                        region.points[0] = BottomLeft;// Bottom left
                        region.points[1] = MiddleLeft; // Middle left
                        region.points[2] = MiddleInnerLeft; // Top left
                        region.points[3] = TopLeft; // top right
                        region.points[4] = TopRight; // Middle right
                        region.points[5] = BottomRight; // Bottom right
                        region.points[6] = BottomLeft;// Bottom left
                    }
                }
            });



            // setting up correct shape for simple regions
            for (let i = 0; i < clickableSimpleRegions.length; i++) {
                if (i === 5) {
                    clickableSimpleRegions[i].label = territoryData[i + 2].Territory;
                    clickableSimpleRegions[i].bottomLeft = convertCoordinates(territoryData[i + 2].BX,territoryData[i + 2].BY);
                    clickableSimpleRegions[i].topRight = convertCoordinates(territoryData[i + 2].TX,territoryData[i + 2].TY);
                    continue;
                }
                clickableSimpleRegions[i].label = territoryData[i].Territory;
                clickableSimpleRegions[i].bottomLeft = convertCoordinates(territoryData[i].BX,territoryData[i].BY);
                clickableSimpleRegions[i].topRight = convertCoordinates(territoryData[i].TX,territoryData[i].TY);
            }

            clickableSimpleRegions.forEach(function (data) { //simple fix for overlapping regions
                if (data.label === 'Gloomrot  North') {

                    data.bottomLeft[1] = data.bottomLeft[1] + 41;
                }
                if (data.label === 'Silverlight Hills') {

                    data.topRight[1] = data.topRight[1] + 2;
                    data.topRight[0] = data.topRight[0] - 150;
                    data.bottomLeft[1] = data.bottomLeft[1] - 215;
                }
                if (data.label === 'Dunley Farmlands') {

                    data.bottomLeft[0] = data.bottomLeft[0] + 150;
                }
                if (data.label === 'Farbane Woods') {

                    data.topRight[1] = data.topRight[1] - 344;
                }
                if (data.label === 'Cursed Forest') {

                    data.bottomLeft[1] = data.bottomLeft[1] - 8;
                }

            });
            //simple fix for overlapping regions
            clickableSimpleRegions.sort((a, b) => b.territoryId - a.territoryId);
            clickableComplexRegions.sort((a, b) => b.territoryId - a.territoryId);
            const polygonStyle = new ol.style.Style({
                fill: new ol.style.Fill({
                    color: 'rgba(255, 255, 255, 0.1)', // Transparent fill color //todo:
                }),
                stroke: new ol.style.Stroke({
                    color: 'rgba(0, 0, 0, 0)', // Transparent stroke color
                    width: 0, // No border
                }),
            });
            clickableComplexRegions.forEach((region) => {
                const polygon = new ol.geom.Polygon([region.points]);

                const feature = new ol.Feature({
                    geometry: polygon,
                    name: region.label,
                    territoryId: region.territoryId,
                });
                feature.setStyle(polygonStyle)
                const priorityLevels = ['Gloomrot North', 'Gloomrot South'];
                const newFeature = removeOverlappingAreasWithExistingFeatures(feature, priorityLevels);
                regionVectorSource.addFeature(newFeature)
            });

            clickableSimpleRegions.forEach((region) => {
                const rectangle = new ol.geom.Polygon([
                    [
                        region.bottomLeft,
                        [region.bottomLeft[0], region.topRight[1]],
                        region.topRight,
                        [region.topRight[0], region.bottomLeft[1]],
                        region.bottomLeft, // Close the polygon
                    ],
                ]);

                const feature = new ol.Feature({
                    geometry: rectangle,
                    name: region.label,
                    territoryId: region.territoryId,
                });
                feature.setStyle(polygonStyle)

                const priorityLevels = ['Dunley Farmlands'];
                const newFeature = removeOverlappingAreasWithExistingFeatures(feature, priorityLevels);
                regionVectorSource.addFeature(newFeature)

            });


            const regionVectorLayer = new ol.layer.Vector({
                source: regionVectorSource
            });

            myMap.addLayer(regionVectorLayer);

            const customSelectStyle = new ol.style.Style({
                fill: new ol.style.Fill({
                    color: 'rgba(255, 255, 255, 0.1)', // Transparent fill color
                }),
                stroke: new ol.style.Stroke({
                    color: 'rgba(0, 0, 0, 0)', // Transparent stroke color
                    width: 0, // No border
                }),
            });


            // select region
            const select = new ol.interaction.Select({
                layers: [regionVectorLayer],
                style: customSelectStyle, // Use the custom style
                condition: ol.events.condition.singleClick, // Enable selection on single click
            });

            // Add the select interaction to the map
            myMap.addInteraction(select);


            const popup = document.getElementById('popup');
            const closer = document.getElementById('popup-closer');

            // Add a click event listener to the closer element to hide the popup
            closer.onclick = function () {
                popup.style.display = 'none';
            };

            // Handle the 'select' event to respond to clicks
            select.on('select', (event) => {
                if (event.selected.length > 0) {
                    // Do something with the selected feature
                    const feature = event.selected[0];
                    const popupOffsetY = 50;
                    const name = feature.get('name');

                    if (selectedFeature === feature) {
                        // If the same feature is selected again, keep the popup open and update its content
                        const popupContent = document.getElementById('popup-content');

                        regionData.forEach(function (data) {
                            if (data.label === name) {
                                if (data.PlayerCount > 1) {
                                    popupContent.innerHTML = `Region: ${data.label}<br> has ${data.PlayerCount} players`;
                                } else if (data.PlayerCount === 1) {
                                    popupContent.innerHTML = `Region: ${data.label}<br> has ${data.PlayerCount} player`;
                                } else {
                                    popupContent.innerHTML = `Region: ${data.label}<br> has no players`;
                                }
                            }
                        });
                    } else {
                        // If a different feature is selected, show the popup and update its position and content
                        selectedFeature = feature;

                        // Get the feature's geometry (in this case, it's a Polygon)
                        const geometry = feature.getGeometry();

                        // Get the center of the geometry (you can adjust this for your custom shapes)
                        const center = ol.extent.getCenter(geometry.getExtent());

                        // Convert the center coordinates to pixel coordinates
                        const pixel = myMap.getPixelFromCoordinate(center);

                        // Position the popup at the center of the feature
                        popup.style.display = 'block';
                        popup.style.left = pixel[0] + 'px';
                        popup.style.top = pixel[1]+popupOffsetY + 'px';

                        // Show information in the popup content
                        const popupContent = document.getElementById('popup-content');

                        regionData.forEach(function (data) {
                            if (data.label === name) {
                                if (data.PlayerCount > 1) {
                                    popupContent.innerHTML = data.label + '<br> has ' + data.PlayerCount + ' players';
                                } else if (data.PlayerCount === 1) {
                                    popupContent.innerHTML = data.label + '<br> has ' + data.PlayerCount + ' player';
                                } else {
                                    popupContent.innerHTML = data.label + '<br> has no players';
                                }
                            }
                        });
                    }
                } else {
                    // If no feature is selected, hide the popup
                    popup.style.display = 'none';
                    selectedFeature = null; // Reset the selected feature variable
                }
            });


            //let territoryPlayerCountElement = document.getElementById(territoryName + "-player-count");
            //if (territoryPlayerCountElement) {
            //    territoryPlayerCountElement.innerHTML = territoryPlayerCount;
            //}
        })
    }

    function updatePlayerPositions() {
        getPlayerPositions().then(playerPositions => {
            try {
                if (playerPositions.Name === "EMPTYSKANKSERVER") Noplayers = true;
            } catch (error) {
                Noplayers = false;
            }
            if (Noplayers) return;
            if (playerPositions.length === 0) {
                return
            }
            let playerFeatures = [];


            playerPositions.forEach(function (position) {
                let playerName = position.Name;
                let playerX = position.X;
                let playerY = position.Y;

                console.log("name:" + playerName + " PosX: " + playerX + " PosY: " + playerY)

                const { X_web, Y_web } = convertCoordinates(playerX, playerY);
// todo: figure this out
                if (X_web !== 9023 && Y_web !== 2919) { //0 0 ingame


                    const feature = new ol.Feature({
                        geometry: new ol.geom.Point(([X_web, Y_web])),
                        name: playerName,
                    });

                    playerFeatures.push(feature);
                    //console.log("name:" + playerName + " PosX: " + X_web + " PosY: " + Y_web)
                }

            });

            const playerVectorSource = new ol.source.Vector({
                features: playerFeatures
            });

            const playerImageStyle = new ol.style.Style({
                image: new ol.style.Icon({
                    color: 'red',
                    src: 'https://skythebro.github.io/SkanksAIO/templates/JS/leaflet/images/Player.png',
                    scale: 1,
                }),
                text: new ol.style.Text({
                    fill: new ol.style.Fill({color: 'white'}),
                    font: '22px Calibri,sans-serif',
                    offsetY: -15,
                }),
            });

            if (playerCounter !== 0) {
                myMap.removeLayer(playerVectorLayer);
                if (customPlayerControl !== null) {
                    visibilityPlayers = customPlayerControl.layer.getVisible()
                    myMap.removeControl(customPlayerControl);
                }
            }

            playerVectorLayer = new ol.layer.Vector({
                source: playerVectorSource,
                style: function (feature) {
                    playerImageStyle.getText().setText(feature.get('name'));
                    return [playerImageStyle];
                }
            });

            if (playerCounter === 0) {
                playerCounter = 1;
            }

            if (customPlayerControl === null) {
                customPlayerControl = new ShowHideControl(playerVectorLayer, "TP", "Toggle Players");
            } else {
                customPlayerControl.layer = playerVectorLayer;
                customPlayerControl.layer.setVisible(visibilityPlayers);
            }


            myMap.addControl(customPlayerControl);
            myMap.addLayer(playerVectorLayer);

        });
    }

    function init() {
        const viewExtent = [-6080, -6080, 6080, 6080];
        const normalExtent = [-3040, -3040, 3040, 3040];

        const minX = viewExtent[0];
        const minY = viewExtent[1];
        const maxX = viewExtent[2];
        const maxY = viewExtent[3];

        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        const tileGrid = new ol.tilegrid.TileGrid({
            extent: normalExtent,
            tileSize: 256,
            resolutions: [23.75, 11.875, 5.9375, 2.96875, 1.484375, 0.7421875],
            origin: [-2200, 2200],
        });

        const myView = new ol.View({
            projection: ol.proj.get('EPSG:3857'),
            center: ([centerX, centerY]), // Set your initial center here (lon, lat)
            zoom: 0,
            extent: viewExtent,
        });

        myMap = new ol.Map({
            target: 'map-container',
            view: myView,
        });

        const layer = new ol.layer.Tile({
            source: new ol.source.XYZ({
                center: ol.proj.fromLonLat([0, 0]),
                zoom: mapMinZoom,
                maxZoom: mapMaxZoom,
                minZoom: mapMinZoom,
                tileGrid: tileGrid,
                tileUrlFunction: function (tileCoord) {
                    const z = tileCoord[0];
                    const x = tileCoord[1];
                    const y = tileCoord[2];
                    return 'https://skythebro.github.io/SkanksAIO/templates/VrisingMapTiles/' + z + '/' + x + '/' + y + '.png';
                },
            })
        });

        updateTerritory();
        // Fetch data initially and get the vector layer
        updatePlayerPositions()
        let interval = 10000; // default if something goes wrong
        getInterval().then(result => {
            interval = result;

            if (!Noplayers) {
                setInterval(() => {
                    updatePlayerPositions();
                }, interval);
            }
        }).catch(error => {
            if (!Noplayers) {
                setInterval(() => {
                    updatePlayerPositions();
                }, interval);
            }
            // Handle any errors that might occur during the fetch or parsing process
            console.error('Error:', error);
        });


        updateCustomMarkers();
        getInterval().then(result => {
            interval = result;


            setInterval(() => {
                updateCustomMarkers();
            }, interval);

        }).catch(error => {
            setInterval(() => {
                updateCustomMarkers();
            }, interval);

            // Handle any errors that might occur during the fetch or parsing process
            console.error('Error:', error);
        });

        myMap.addLayer(layer)

        myMap.on('pointerdrag', () => {
            if (selectedFeature) {
                var popup = document.getElementById('popup');
                popup.style.display = 'none';
                selectedFeature = null; // Reset the selected feature variable
            }
        });

        //debug so i can see coords
        const coordinatesInfo = document.getElementById('coordinates-info');
        myMap.on('click', function (event) {
            const coordinate = event.coordinate;
            const [xMap, yMap] = coordinate;
            const [ xGame, yGame ] = convertCoordinatesArray(xMap, yMap);

            coordinatesInfo.innerHTML = `Map coords: X: ${xMap}, Y: ${yMap}<br>Game coords: xGame: ${xGame.toFixed(2)}, yGame: ${yGame.toFixed(2)}`;
        });

        myMap.on('click', (e) => {
            markerVectorLayer.getFeatures(e.pixel).then((clickedFeatures) => {
                if (clickedFeatures.length) {
                    // Get clustered Coordinates
                    const features = clickedFeatures[0].get('features');
                    if (features.length > 1) {
                        const extent = ol.extent.boundingExtent(
                            features.map((r) => r.getGeometry().getCoordinates())
                        );
                        myMap.getView().fit(extent, {duration: 1000, padding: [50, 50, 50, 50]});
                    }
                }
            });
        });

        window.addEventListener("resize", function () {
            myMap.updateSize();
        });
    }


    document.addEventListener("DOMContentLoaded", function () {
        init();
    });
</script>
</body>
</html>
